---
title: for loop for multiplication tables
date: 2025-05-08
weight: 37
---

Okay, let's create a **multiplication table** using a `for` loop! ‚ú® This is a perfect example to show how a `for` loop helps automate tasks we'd otherwise have to repeat manually.

Imagine you want to print the multiplication table for a number, say 5. You'd normally do this:
*   5 times 1 equals 5
*   5 times 2 equals 10
*   ...
*   5 times 10 equals 50

Writing all those lines manually would be tedious! üò© But with a `for` loop, we can tell the computer: "**For each number** from 1 to 10, calculate and print the result of multiplying our number by that number."

Here's why a `for` loop is a great choice for this task: we **know exactly how many times** we need to repeat the multiplication ‚Äì 10 times (for multiplying by 1 through 10). When the number of iterations is known, the `for` loop is generally more suitable than a `while` loop.

We'll use the **`range()`** function again! üî¢ Remember, `range()` generates a sequence of numbers.

Here's the basic code structure for a multiplication table, drawing from the sources:

```python
# Let's pick a number for the table üçé
num = 5

# We need to multiply 'num' by numbers 1 through 10.
# range(1, 11) will give us the numbers 1, 2, 3, ..., 10
for i in range(1, 11): # The variable 'i' will be 1, then 2, then 3, ... up to 10
    # Inside the loop, for each value of 'i':
    # Calculate the result: num multiplied by the current value of i
    result = num * i

    # Print the line of the table. We can use formatted printing for a nice output!
    print(f"{num} times {i} is {result}") # This line runs 10 times!

# After the loop finishes (i.e., range(1, 11) is exhausted), the program continues here.
print("Finished printing the table! üëç")
```

Let's trace what happens in the loop:

1.  The variable `num` is set to 5.
2.  The `for` loop starts, using `range(1, 11)`. This generates numbers starting from 1 and going up to (but not including) 11. So, `i` will take values 1, 2, 3, 4, 5, 6, 7, 8, 9, and 10.
3.  **First Iteration:** `i` is 1.
    *   `result` is calculated as `num * i` which is `5 * 1`, so `result` is 5.
    *   `print(f"{num} times {i} is {result}")` prints "5 times 1 is 5".
4.  **Second Iteration:** `i` is 2.
    *   `result` is calculated as `num * i` which is `5 * 2`, so `result` is 10.
    *   `print(f"{num} times {i} is {result}")` prints "5 times 2 is 10".
5.  This continues for every number generated by `range(1, 11)`.
6.  **Last Iteration:** `i` is 10.
    *   `result` is calculated as `num * i` which is `5 * 10`, so `result` is 50.
    *   `print(f"{num} times {i} is {result}")` prints "5 times 10 is 50".
7.  `range(1, 11)` has no more numbers. The loop finishes.
8.  The code after the loop runs: `print("Finished printing the table! üëç")`.

This way, the `for` loop automatically handles going through each number (1 to 10) and performing the multiplication and printing for us! üéâ It replaces the need to write 10 separate `print` statements.

Using `range(start, stop)` is shown in the sources to specify the starting and ending points for the loop. If we had used `range(10)` as in some basic examples, `i` would go from 0 to 9, which might not be what we want for a standard multiplication table. `range(1, 11)` correctly gives us the numbers 1 through 10.

Just like calculating factorial or adding numbers, multiplication tables are a clear instance where the predictable number of steps makes the `for` loop with `range()` the perfect tool. You can easily adapt this code to print the table for any number by changing the value of the `num` variable. üëç